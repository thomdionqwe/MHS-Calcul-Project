"use strict";
const moo = require('moo');
function latex2js(latex, options) {
    function err(errorHandler) {
        let { message, line, col, latex } = errorHandler;
        let bottomSpaces = " ".repeat(col - 1) + "^";
        return new Error(message + "\n\n" + latex + "\n" + bottomSpaces + "\n");
    }
    function Tokenizer(str) {
        const Lexer = moo.compile({
            space: { match: /\s+/, lineBreaks: true },
            number: /0|\d+\.\d+|[1-9]\d*/,
            constant: ["e", "\\pi", "\\tau"],
            lBraces: "{",
            rBraces: "}",
            command: /\\[a-zA-Z]+/,
            differential: /d\\[a-zA-Z]+|d[a-zA-Z]{1}/,
            any: /[a-zA-Z]+?/,
            literal: [",", "(", ")"],
            ops: ["+", "-", "!", "%", "=>", "=<", "<=", "=", ">", "<"],
            sub: "_",
            sup: "^"
        });
        Lexer.reset(str);
        const Tokens = [];
        let i = 0;
        for (let token of Lexer) {
            Tokens.push({ ...token, index: i });
            i++;
        }
        Tokens.push("end");
        return Tokens;
    }
    function Parser(tokens, _options) {
        const parsed = [], JS = [];
        let i = 0, _sub = false, _sum = false, _sumvar;
        const nextToken = () => {
            i += 1;
            return tokens[i];
        };
        function eat(token) {
            if (token.type === "command") {
                if (token.value === "\\frac") {
                    const frac = eatFraction();
                    return frac;
                }
                else if (token.value === "\\sqrt") {
                    const sqrt = eatSqrt();
                    return sqrt;
                }
                else if (token.value === "\\text") {
                    const text = eatText();
                    return text;
                }
                else if (token.value === "\\sum") {
                    const sum = eatSum();
                    return sum;
                }
                else if (token.value === "\\int") {
                    const int = eatInt();
                    return int;
                }
            }
            else if (token.type === "any" || token.type === "number") {
                let j = i + 1;
                JS.push(token.text);
                if (_sum)
                    _sumvar = token.text;
                if (tokens[j] && tokens[j].type === "any" && !_sub)
                    JS.push("*");
                return token.text;
            }
            else if (token.type === "ops") {
                JS.push(" " + token.text + " ");
                return token.text;
            }
            else if (token.type === "lBraces") {
                return eatGroup();
            }
            else if (token.type === "sup") {
                return eatSup();
            }
            else if (token.type === "sub") {
                return eatSub();
            }
            else if (token.type === "space") {
                JS.push(token.text);
                return token.text;
            }
            else if (token.type === "literal") {
                JS.push(token.text);
                return token.text;
            }
            else if (token.type === "constant") {
                if (_options.constantPrefix) {
                    JS.push(_options.constantPrefix + ".");
                    if (token.text.includes("\\")) {
                        JS.push(_options.constants[token.text.replace("\\", "")]);
                    }
                    else {
                        JS.push(_options.constants[token.text]);
                    }
                }
                return token.text;
            }
        }
        function eatFraction() {
            const frac = { top: [], bottom: [] };
            let nexttoken = nextToken();
            if (nexttoken.type !== "lBraces") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '{'\n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            nexttoken = nextToken();
            JS.push("(");
            while (nexttoken.type !== "rBraces") {
                frac.top.push(eat(nexttoken));
                nexttoken = nextToken();
            }
            nexttoken = nextToken();
            JS.push(")");
            JS.push("/");
            if (nexttoken.type !== "lBraces") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '{'\n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            JS.push("(");
            nexttoken = nextToken();
            while (nexttoken.type !== "rBraces") {
                frac.bottom.push(eat(nexttoken));
                nexttoken = nextToken();
            }
            JS.push(")");
            return { type: "fraction", body: frac };
        }
        function eatGroup(p = true, s = false) {
            let nexttoken = nextToken();
            const group = { group: [] };
            if (p)
                JS.push("(");
            if (s)
                _sum = true;
            while (nexttoken.type !== "rBraces") {
                group.group.push(eat(nexttoken));
                _sum = false;
                nexttoken = nextToken();
            }
            if (p)
                JS.push(")");
            return group;
        }
        function eatSup() {
            const sup = { sup: [] };
            JS.push("**");
            let nexttoken = nextToken();
            if (nexttoken.type !== "lBraces") {
                sup.sup.push(eat(nexttoken));
            }
            else if (nexttoken.type === "lBraces") {
                sup.sup.push(eatGroup());
            }
            return sup;
        }
        function eatSub() {
            const sub = { sub: [] };
            JS.push("_");
            _sub = true;
            let nexttoken = nextToken();
            if (nexttoken.type !== "lBraces") {
                sub.sub.push(eat(nexttoken));
            }
            else if (nexttoken.type === "lBraces") {
                sub.sub.push(eatGroup(false));
            }
            _sub = false;
            return sub;
        }
        function eatSqrt() {
            const sqrt = { sqrt: [] };
            let nexttoken = nextToken();
            if (nexttoken.type !== "lBraces") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '{'\n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            nexttoken = nextToken();
            JS.push(_options.functionPrefix + "." + _options.functions.sqrt + "(");
            while (nexttoken.type !== "rBraces") {
                sqrt.sqrt.push(eat(nexttoken));
                nexttoken = nextToken();
            }
            JS.push(")");
            return sqrt;
        }
        function eatText() {
            const text = { text: [] };
            let nexttoken = nextToken();
            if (nexttoken.type !== "lBraces") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '{'\n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            nexttoken = nextToken();
            _sub = true;
            while (nexttoken.type !== "rBraces") {
                text.text.push(eat(nexttoken));
                nexttoken = nextToken();
            }
            _sub = false;
            return text;
        }
        function eatSum() {
            const sum = { sum: { bottom: [], top: [], body: [] } };
            let nexttoken = nextToken();
            JS.push(_options.functionPrefix + "." + _options.functions.sum + "(");
            if (nexttoken.type !== "sub") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '_' for Sum function argument \n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            nexttoken = nextToken();
            console.log(nexttoken.type);
            if (nexttoken.type !== "lBraces") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '{' for Sum function argument \n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            sum.sum.bottom.push(eatGroup(false, true));
            JS.push(", ");
            nexttoken = nextToken();
            if (nexttoken.type !== "sup") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '^' for Sum function argument \n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            nexttoken = nextToken();
            if (nexttoken.type !== "lBraces") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '{' for Sum function argument \n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            sum.sum.top.push(eatGroup(false));
            JS.push(", ");
            nexttoken = nextToken();
            if (nexttoken.type !== "lBraces") {
                throw err({
                    col: nexttoken.col,
                    line: nexttoken.line,
                    latex: latex,
                    message: "Error while parsing latex: unexpected token '" + nexttoken.text + "', expected '{' for Sum function argument \n At line " + nexttoken.line + ", col " + nexttoken.col
                });
            }
            if (_sumvar) {
                sum.sum.body.push(_sumvar);
                JS.push(_sumvar + " => ");
            }
            ;
            sum.sum.body.push(eatGroup(false));
            JS.push(")");
            return sum;
        }
        function eatInt() {
            let nexttoken = nextToken();
            const int = { int: { top: [], bottom: [], body: [], _var: "" } };
            JS.push(_options.functionPrefix + "." + _options.functions.int);
            JS.push(`(`);
            if (nexttoken.type !== "sub") {
                JS.push(`null, `);
            }
            else {
                nexttoken = nextToken();
                if (nexttoken.type !== "lBraces") {
                    int.int.bottom.push(eat(nextToken()));
                }
                else {
                    int.int.bottom.push(eatGroup(false));
                }
                JS.push(", ");
            }
            nexttoken = nextToken();
            if (nexttoken.type !== "sup") {
                JS.push(`null, \"`);
            }
            else if (nexttoken.type === "sup") {
                nexttoken = nextToken();
                if (nexttoken.type !== "lBraces") {
                    int.int.top.push(eat(nextToken()));
                }
                else {
                    int.int.top.push(eatGroup(false));
                }
                JS.push(", \"");
                nexttoken = nextToken();
            }
            while (nexttoken.type !== "differential") {
                int.int.body.push(eat(nexttoken));
                nexttoken = nextToken();
            }
            JS.push("\", ");
            let diff = nexttoken;
            int.int._var = diff.text.slice(1, diff.text.length);
            JS.push(`d="${int.int._var}")`);
            return int;
        }
        while (tokens[i] !== "end") {
            parsed.push(eat(tokens[i]));
            i++;
        }
        return [parsed, JS.join("")];
    }
    const DefaultOptions = {
        LatexAST: false,
        constantPrefix: "_Math",
        functionPrefix: "_Math",
        constants: {
            e: "E",
            pi: "PI",
            tau: "TAU"
        },
        functions: {
            int: "Int",
            sum: "Sum",
            sqrt: "Sqrt"
        }
    };
    if (options)
        Object.assign(DefaultOptions, options);
    const tokens = Tokenizer(latex);
    const parsed = Parser(tokens, DefaultOptions);
    if (DefaultOptions.LatexAST) {
        return parsed[0];
    }
    else {
        return parsed[1];
    }
}
module.exports = latex2js;
