"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nextafter_1 = __importDefault(require("nextafter"));
/**
 * @module interval-arithmetic/round-math
 */
function identity(v) {
    return v;
}
function prev(v) {
    if (v === Infinity) {
        return v;
    }
    return (0, nextafter_1.default)(v, -Infinity);
}
function next(v) {
    if (v === -Infinity) {
        return v;
    }
    return (0, nextafter_1.default)(v, Infinity);
}
function toInteger(x) {
    return x < 0 ? Math.ceil(x) : Math.floor(x);
}
const cache = {
    prev: prev,
    next: next
};
/**
 * @alias module:interval-arithmetic/round-math
 */
const round = {
    /**
     * Computes the previous IEEE floating point representation of `v`
     * @example
     * Interval.round.safePrev(1)          // 0.9999999999999999
     * Interval.round.safePrev(3)          // 2.9999999999999996
     * Interval.round.safePrev(Infinity)   // Infinity
     * @param {number} v
     * @return {number}
     * @function
     */
    safePrev: prev,
    /**
     * Computes the next IEEE floating point representation of `v`
     * @example
     * Interval.round.safeNext(1)          // 1.0000000000000002
     * Interval.round.safeNext(3)          // 3.0000000000000004
     * Interval.round.safeNext(-Infinity)  // -Infinity
     * @param {number} v
     * @return {number}
     * @function
     */
    safeNext: next,
    prev(x) {
        return cache.prev(x);
    },
    next(x) {
        return cache.next(x);
    },
    // prettier-ignore
    addLo(x, y) { return round.prev(x + y); },
    // prettier-ignore
    addHi(x, y) { return round.next(x + y); },
    // prettier-ignore
    subLo(x, y) { return round.prev(x - y); },
    // prettier-ignore
    subHi(x, y) { return round.next(x - y); },
    // prettier-ignore
    mulLo(x, y) { return round.prev(x * y); },
    // prettier-ignore
    mulHi(x, y) { return round.next(x * y); },
    // prettier-ignore
    divLo(x, y) { return round.prev(x / y); },
    // prettier-ignore
    divHi(x, y) { return round.next(x / y); },
    // prettier-ignore
    intLo(x) { return toInteger(round.prev(x)); },
    // prettier-ignore
    intHi(x) { return toInteger(round.next(x)); },
    // prettier-ignore
    logLo(x) { return round.prev(Math.log(x)); },
    // prettier-ignore
    logHi(x) { return round.next(Math.log(x)); },
    // prettier-ignore
    expLo(x) { return round.prev(Math.exp(x)); },
    // prettier-ignore
    expHi(x) { return round.next(Math.exp(x)); },
    // prettier-ignore
    sinLo(x) { return round.prev(Math.sin(x)); },
    // prettier-ignore
    sinHi(x) { return round.next(Math.sin(x)); },
    // prettier-ignore
    cosLo(x) { return round.prev(Math.cos(x)); },
    // prettier-ignore
    cosHi(x) { return round.next(Math.cos(x)); },
    // prettier-ignore
    tanLo(x) { return round.prev(Math.tan(x)); },
    // prettier-ignore
    tanHi(x) { return round.next(Math.tan(x)); },
    // prettier-ignore
    asinLo(x) { return round.prev(Math.asin(x)); },
    // prettier-ignore
    asinHi(x) { return round.next(Math.asin(x)); },
    // prettier-ignore
    acosLo(x) { return round.prev(Math.acos(x)); },
    // prettier-ignore
    acosHi(x) { return round.next(Math.acos(x)); },
    // prettier-ignore
    atanLo(x) { return round.prev(Math.atan(x)); },
    // prettier-ignore
    atanHi(x) { return round.next(Math.atan(x)); },
    // polyfill required for hyperbolic functions
    // prettier-ignore
    sinhLo(x) { return round.prev(Math.sinh(x)); },
    // prettier-ignore
    sinhHi(x) { return round.next(Math.sinh(x)); },
    // prettier-ignore
    coshLo(x) { return round.prev(Math.cosh(x)); },
    // prettier-ignore
    coshHi(x) { return round.next(Math.cosh(x)); },
    // prettier-ignore
    tanhLo(x) { return round.prev(Math.tanh(x)); },
    // prettier-ignore
    tanhHi(x) { return round.next(Math.tanh(x)); },
    /**
     * @ignore
     * ln(power) exponentiation of x
     * @param {number} x
     * @param {number} power
     * @returns {number}
     */
    powLo(x, power) {
        if (power % 1 !== 0) {
            // power has decimals
            return round.prev(Math.pow(x, power));
        }
        let y = (power & 1) === 1 ? x : 1;
        power >>= 1;
        while (power > 0) {
            x = round.mulLo(x, x);
            if ((power & 1) === 1) {
                y = round.mulLo(x, y);
            }
            power >>= 1;
        }
        return y;
    },
    /**
     * @ignore
     * ln(power) exponentiation of x
     * @param {number} x
     * @param {number} power
     * @returns {number}
     */
    powHi(x, power) {
        if (power % 1 !== 0) {
            // power has decimals
            return round.next(Math.pow(x, power));
        }
        let y = (power & 1) === 1 ? x : 1;
        power >>= 1;
        while (power > 0) {
            x = round.mulHi(x, x);
            if ((power & 1) === 1) {
                y = round.mulHi(x, y);
            }
            power >>= 1;
        }
        return y;
    },
    // prettier-ignore
    sqrtLo(x) { return round.prev(Math.sqrt(x)); },
    // prettier-ignore
    sqrtHi(x) { return round.next(Math.sqrt(x)); },
    /**
     * Most operations on intervals will cary the rounding error so that the
     * resulting interval correctly represents all the possible values, this feature
     * can be disabled by calling this method allowing a little boost in the
     * performance while operating on intervals
     *
     * @see module:interval-arithmetic/round-math.enable
     * @example
     * var x = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     *
     * Interval.round.disable()
     * var y = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * y // equal to {lo: 2, hi: 2}
     * @function
     */
    disable() {
        cache.next = cache.prev = identity;
    },
    /**
     * Enables IEEE previous/next floating point wrapping of values (enabled by
     * default)
     * @see module:interval-arithmetic/round-math.disable
     * @example
     * var x = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     *
     * Interval.round.disable()
     * var y = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * y // equal to {lo: 2, hi: 2}
     *
     * Interval.round.enable()
     * var z = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * z // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     * @function
     */
    enable() {
        cache.next = next;
        cache.prev = prev;
    }
};
exports.default = round;
//# sourceMappingURL=round.js.map