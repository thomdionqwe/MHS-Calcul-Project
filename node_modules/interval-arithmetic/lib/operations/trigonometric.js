'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tanh = exports.cosh = exports.sinh = exports.atan = exports.acos = exports.asin = exports.tan = exports.sin = exports.cos = void 0;
const interval_1 = require("../interval");
const round_1 = __importDefault(require("../round"));
const constants_1 = __importDefault(require("../constants"));
const utils = __importStar(require("./utils"));
const arithmetic = __importStar(require("./arithmetic"));
const algebra = __importStar(require("./algebra"));
const misc = __importStar(require("./misc"));
/**
 * @mixin trigonometric
 */
/**
 * Checks if an interval is
 * - [-Infinity, -Infinity]
 * - [Infinity, Infinity]
 * @param {Interval} x
 * @returns {boolean}
 */
function onlyInfinity(x) {
    return !isFinite(x.lo) && x.lo === x.hi;
}
/**
 * moves interval 2PI * k to the right until both bounds are positive
 * @param interval
 */
function handleNegative(interval) {
    if (interval.lo < 0) {
        if (interval.lo === -Infinity) {
            interval.lo = 0;
            interval.hi = Infinity;
        }
        else {
            const n = Math.ceil(-interval.lo / constants_1.default.PI_TWICE_LOW);
            interval.lo += constants_1.default.PI_TWICE_LOW * n;
            interval.hi += constants_1.default.PI_TWICE_LOW * n;
        }
    }
    return interval;
}
/**
 * Computes the cosine of `x`
 *
 * @example
 * ```typescript
 * Interval.cos(
 *   Interval(0, 0)
 * ) // Interval(1, 1)
 * ```
 *
 * @example
 * ```typescript
 * Interval.cos(
 *   Interval(0, Math.PI / 2)
 * ) // Interval(0, 1)
 * ```
 *
 * @example
 * ```typescript
 * Interval.cos(
 *   Interval(3 * Math.PI / 2, 3 * Math.PI)
 * ) // Interval(-1, 1)
 * ```
 *
 * @example
 * ```typescript
 * Interval.cos(
 *   Interval(-Infinity, x)
 * )
 * // Interval(-1, 1) if x > -Infinity
 * // Interval.EMPTY otherwise
 * ```
 *
 * @example
 * ```typescript
 * Interval.cos(
 *   Interval(x, Infinity)
 * )
 * // Interval(-1, 1) if x < Infinity
 * // Interval.EMPTY otherwise
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function cos(x) {
    if (utils.isEmpty(x) || onlyInfinity(x)) {
        return constants_1.default.EMPTY;
    }
    // create a clone of `x` because the clone is going to be modified
    const cache = new interval_1.Interval().set(x.lo, x.hi);
    handleNegative(cache);
    const pi2 = constants_1.default.PI_TWICE;
    const t = algebra.fmod(cache, pi2);
    if (misc.width(t) >= pi2.lo) {
        return new interval_1.Interval(-1, 1);
    }
    // when t.lo > pi it's the same as
    // -cos(t - pi)
    if (t.lo >= constants_1.default.PI_HIGH) {
        const cosv = cos(arithmetic.sub(t, constants_1.default.PI));
        return arithmetic.negative(cosv);
    }
    const lo = t.lo;
    const hi = t.hi;
    const rlo = round_1.default.cosLo(hi);
    const rhi = round_1.default.cosHi(lo);
    // it's ensured that t.lo < pi and that t.lo >= 0
    if (hi <= constants_1.default.PI_LOW) {
        // when t.hi < pi
        // [cos(t.lo), cos(t.hi)]
        return new interval_1.Interval(rlo, rhi);
    }
    else if (hi <= pi2.lo) {
        // when t.hi < 2pi
        // [-1, max(cos(t.lo), cos(t.hi))]
        return new interval_1.Interval(-1, Math.max(rlo, rhi));
    }
    else {
        // t.lo < pi and t.hi > 2pi
        return new interval_1.Interval(-1, 1);
    }
}
exports.cos = cos;
/**
 * Computes the sine of `x`
 *
 * @example
 * ```typescript
 * Interval.sin(
 *   Interval(0, 0)
 * ) // Interval(0, 0)
 * ```
 *
 * @example
 * ```typescript
 * Interval.sin(
 *   Interval(0, Math.PI / 2)
 * ) // Interval(0, 1)
 * ```
 *
 * @example
 * ```typescript
 * Interval.sin(
 *   Interval(Math.PI / 2, Math.PI / 2)
 * ) // Interval(1, 1)
 * ```
 *
 * @example
 * ```typescript
 * Interval.sin(
 *   Interval(Math.PI / 2, -Math.PI / 2)
 * ) // Interval(-1, 1)
 * ```
 *
 * @example
 * ```typescript
 * Interval.sin(
 *   Interval(Math.PI, 3 * Math.PI / 2)
 * ) // Interval(-1, 0)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function sin(x) {
    if (utils.isEmpty(x) || onlyInfinity(x)) {
        return constants_1.default.EMPTY;
    }
    return cos(arithmetic.sub(x, constants_1.default.PI_HALF));
}
exports.sin = sin;
/**
 * Computes the tangent of `x`
 *
 * @example
 * ```typescript
 * Interval.tan(
 *   Interval(-Math.PI / 4, Math.PI / 4)
 * ) // Interval(-1, 1)
 * ```
 *
 * @example
 * ```typescript
 * Interval.tan(
 *   Interval(0, Math.PI / 2)
 * ) // Interval.WHOLE
 * ```
 *
 * @example
 * ```typescript
 * Interval.tan(
 *   Interval(-Infinity, x)
 * )
 * // Interval.WHOLE if x > -Infinity
 * // Interval.EMPTY otherwise
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function tan(x) {
    if (utils.isEmpty(x) || onlyInfinity(x)) {
        return constants_1.default.EMPTY;
    }
    // create a clone of `x` because the clone is going to be modified
    const cache = new interval_1.Interval().set(x.lo, x.hi);
    handleNegative(cache);
    const pi = constants_1.default.PI;
    let t = algebra.fmod(cache, pi);
    if (t.lo >= constants_1.default.PI_HALF_LOW) {
        t = arithmetic.sub(t, pi);
    }
    if (t.lo <= -constants_1.default.PI_HALF_LOW || t.hi >= constants_1.default.PI_HALF_LOW) {
        return constants_1.default.WHOLE;
    }
    return new interval_1.Interval(round_1.default.tanLo(t.lo), round_1.default.tanHi(t.hi));
}
exports.tan = tan;
/**
 * Computes the arcsine of `x`
 *
 * @example
 * ```typescript
 * Interval.asin(
 *   Interval(-1.57079633, 1.57079633)
 * )  // Interval(-10, 10)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function asin(x) {
    if (utils.isEmpty(x) || x.hi < -1 || x.lo > 1) {
        return constants_1.default.EMPTY;
    }
    const lo = x.lo <= -1 ? -constants_1.default.PI_HALF_HIGH : round_1.default.asinLo(x.lo);
    const hi = x.hi >= 1 ? constants_1.default.PI_HALF_HIGH : round_1.default.asinHi(x.hi);
    return new interval_1.Interval(lo, hi);
}
exports.asin = asin;
/**
 * Computes the arccosine of `x`
 *
 * @example
 * ```typescript
 * Interval.acos(
 *   Interval(0, 1)
 * )  // Interval(0, Math.PI / 2)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function acos(x) {
    if (utils.isEmpty(x) || x.hi < -1 || x.lo > 1) {
        return constants_1.default.EMPTY;
    }
    const lo = x.hi >= 1 ? 0 : round_1.default.acosLo(x.hi);
    const hi = x.lo <= -1 ? constants_1.default.PI_HIGH : round_1.default.acosHi(x.lo);
    return new interval_1.Interval(lo, hi);
}
exports.acos = acos;
/**
 * Computes the arctangent of `x`
 *
 * @example
 * ```typescript
 * Interval.atan(
 *   Interval(-1, 1)
 * )  // Interval(-0.785398163, 0.785398163)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function atan(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    return new interval_1.Interval(round_1.default.atanLo(x.lo), round_1.default.atanHi(x.hi));
}
exports.atan = atan;
/**
 * Computes the hyperbolic sine of `x`
 *
 * @example
 * ```typescript
 * Interval.sinh(
 *   Interval(-2, 2)
 * )  // Interval(-3.6286040785, 3.6286040785)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function sinh(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    return new interval_1.Interval(round_1.default.sinhLo(x.lo), round_1.default.sinhHi(x.hi));
}
exports.sinh = sinh;
/**
 * Computes the hyperbolic cosine of `x`
 *
 * @example
 * ```typescript
 * Interval.cosh(
 *   Interval(-2, 2)
 * )  // Interval(1, 3.76219569108)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function cosh(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    if (x.hi < 0) {
        return new interval_1.Interval(round_1.default.coshLo(x.hi), round_1.default.coshHi(x.lo));
    }
    else if (x.lo >= 0) {
        return new interval_1.Interval(round_1.default.coshLo(x.lo), round_1.default.coshHi(x.hi));
    }
    else {
        return new interval_1.Interval(1, round_1.default.coshHi(-x.lo > x.hi ? x.lo : x.hi));
    }
}
exports.cosh = cosh;
/**
 * Computes the hyperbolic tangent of `x`
 *
 * @example
 * ```typescript
 * Interval.tanh(
 *   Interval(-Infinity, Infinity)
 * )  // Interval(-1, 1)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function tanh(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    return new interval_1.Interval(round_1.default.tanhLo(x.lo), round_1.default.tanhHi(x.hi));
}
exports.tanh = tanh;
//# sourceMappingURL=trigonometric.js.map