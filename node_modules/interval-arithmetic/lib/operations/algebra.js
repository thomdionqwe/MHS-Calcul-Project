"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nthRoot = exports.sqrt = exports.pow = exports.multiplicativeInverse = exports.fmod = void 0;
const interval_1 = require("../interval");
const round_1 = __importDefault(require("../round"));
const constants_1 = __importDefault(require("../constants"));
const utils = __importStar(require("./utils"));
const arithmetic = __importStar(require("./arithmetic"));
/**
 * @mixin algebra
 */
/**
 * Computes `x mod y (x - k * y)`
 *
 * @example
 * ```typescript
 * Interval.fmod(
 *   Interval(5.3, 5.3),
 *   Interval(2, 2)
 * ) // Interval(1.3, 1.3)
 * Interval.fmod(
 *   Interval(5, 7),
 *   Interval(2, 3)
 * ) // Interval(2, 5)
 * // explanation: [5, 7] - [2, 3] * 1 = [2, 5]
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function fmod(x, y) {
    if (utils.isEmpty(x) || utils.isEmpty(y)) {
        return constants_1.default.EMPTY;
    }
    const yb = x.lo < 0 ? y.lo : y.hi;
    let n = x.lo / yb;
    if (n < 0)
        n = Math.ceil(n);
    else
        n = Math.floor(n);
    // x mod y = x - n * y
    return arithmetic.sub(x, arithmetic.mul(y, new interval_1.Interval(n)));
}
exports.fmod = fmod;
/**
 * Computes `1 / x`
 *
 * @example
 * ```typescript
 * Interval.multiplicativeInverse(
 *   Interval(2, 6)
 * )  // Interval(1/6, 1/2)
 * Interval.multiplicativeInverse(
 *   Interval(-6, -2)
 * )  // Interval(-1/2, -1/6)
 * ```
 *
 * @param {Interval} x
 * @returns {Interval}
 */
function multiplicativeInverse(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    if (utils.zeroIn(x)) {
        if (x.lo !== 0) {
            if (x.hi !== 0) {
                // [negative, positive]
                return constants_1.default.WHOLE;
            }
            else {
                // [negative, zero]
                return new interval_1.Interval(Number.NEGATIVE_INFINITY, round_1.default.divHi(1, x.lo));
            }
        }
        else {
            if (x.hi !== 0) {
                // [zero, positive]
                return new interval_1.Interval(round_1.default.divLo(1, x.hi), Number.POSITIVE_INFINITY);
            }
            else {
                // [zero, zero]
                return constants_1.default.EMPTY;
            }
        }
    }
    else {
        // [positive, positive]
        return new interval_1.Interval(round_1.default.divLo(1, x.hi), round_1.default.divHi(1, x.lo));
    }
}
exports.multiplicativeInverse = multiplicativeInverse;
/**
 * Computes `x^power` given that `power` is an integer
 *
 * If `power` is an Interval it must be a singletonInterval i.e. `x^x` is not
 * supported yet
 *
 * If `power` is a rational number use {@link nthRoot} instead
 *
 * @example
 * ```typescript
 * // 2^{-2}
 * Interval.pow(
 *   Interval(2, 2),
 *   -2
 * )  // Interval(1/4, 1/4)
 * // [2,3]^2
 * Interval.pow(
 *   Interval(2, 3),
 *   2
 * )  // Interval(4, 9)
 * // [2,3]^0
 * Interval.pow(
 *   Interval(2, 3),
 *   0
 * )  // Interval(1, 1)
 * // with a singleton interval
 * Interval.pow(
 *   Interval(2, 3),
 *   Interval(2)
 * )  // Interval(4, 9)
 * ```
 *
 * @param {Interval} x
 * @param {number|Interval} power A number of a singleton interval
 * @returns {Interval}
 */
function pow(x, power) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    if (typeof power === 'object') {
        if (!utils.isSingleton(power)) {
            return constants_1.default.EMPTY;
        }
        power = power.lo;
    }
    if (power === 0) {
        if (x.lo === 0 && x.hi === 0) {
            // 0^0
            return constants_1.default.EMPTY;
        }
        else {
            // x^0
            return constants_1.default.ONE;
        }
    }
    else if (power < 0) {
        // compute [1 / x]^-power if power is negative
        return pow(multiplicativeInverse(x), -power);
    }
    // power > 0
    if (Number.isSafeInteger(power)) {
        // power is integer
        if (x.hi < 0) {
            // [negative, negative]
            // assume that power is even so the operation will yield a positive interval
            // if not then just switch the sign and order of the interval bounds
            const yl = round_1.default.powLo(-x.hi, power);
            const yh = round_1.default.powHi(-x.lo, power);
            if ((power & 1) === 1) {
                // odd power
                return new interval_1.Interval(-yh, -yl);
            }
            else {
                // even power
                return new interval_1.Interval(yl, yh);
            }
        }
        else if (x.lo < 0) {
            // [negative, positive]
            if ((power & 1) === 1) {
                return new interval_1.Interval(-round_1.default.powLo(-x.lo, power), round_1.default.powHi(x.hi, power));
            }
            else {
                // even power means that any negative number will be zero (min value = 0)
                // and the max value will be the max of x.lo^power, x.hi^power
                return new interval_1.Interval(0, round_1.default.powHi(Math.max(-x.lo, x.hi), power));
            }
        }
        else {
            // [positive, positive]
            return new interval_1.Interval(round_1.default.powLo(x.lo, power), round_1.default.powHi(x.hi, power));
        }
    }
    else {
        console.warn('power is not an integer, you should use nth-root instead, returning an empty interval');
        return constants_1.default.EMPTY;
    }
}
exports.pow = pow;
/**
 * Computes `sqrt(x)`, alias for `nthRoot(x, 2)`
 *
 * @example
 * ```typescript
 * Interval.sqrt(
 *   Interval(4, 9)
 * ) // Interval(prev(2), next(3))
 * ```
 *
 * @param {Interval} x
 * @returns {Interval}
 */
function sqrt(x) {
    return nthRoot(x, 2);
}
exports.sqrt = sqrt;
/**
 * Computes `x^(1/n)`
 *
 * @example
 * ```typescript
 * Interval.nthRoot(
 *   Interval(-27, -8),
 *   3
 * ) // Interval(-3, -2)
 * ```
 *
 * @param {Interval} x
 * @param {number|Interval} n A number or a singleton interval
 * @return {Interval}
 */
function nthRoot(x, n) {
    if (utils.isEmpty(x) || n < 0) {
        // compute 1 / x^-power if power is negative
        return constants_1.default.EMPTY;
    }
    // singleton interval check
    if (typeof n === 'object') {
        if (!utils.isSingleton(n)) {
            return constants_1.default.EMPTY;
        }
        n = n.lo;
    }
    const power = 1 / n;
    if (x.hi < 0) {
        // [negative, negative]
        if (Number.isSafeInteger(n) && (n & 1) === 1) {
            // when n is odd we can always take the nth root
            const yl = round_1.default.powHi(-x.lo, power);
            const yh = round_1.default.powLo(-x.hi, power);
            return new interval_1.Interval(-yl, -yh);
        }
        // n is not odd therefore there's no nth root
        return constants_1.default.EMPTY;
    }
    else if (x.lo < 0) {
        // [negative, positive]
        const yp = round_1.default.powHi(x.hi, power);
        if (Number.isSafeInteger(n) && (n & 1) === 1) {
            // nth root of x.lo is possible (n is odd)
            const yn = -round_1.default.powHi(-x.lo, power);
            return new interval_1.Interval(yn, yp);
        }
        return new interval_1.Interval(0, yp);
    }
    else {
        // [positive, positive]
        return new interval_1.Interval(round_1.default.powLo(x.lo, power), round_1.default.powHi(x.hi, power));
    }
}
exports.nthRoot = nthRoot;
//# sourceMappingURL=algebra.js.map